"""
Origin Exploitation Engine (OEE) - Advanced Origin IP Discovery and Exploitation
"""

import re
import json
import socket
import subprocess
import ipaddress
from typing import List, Dict, Set, Optional, Tuple
from urllib.parse import urlparse, urljoin
from concurrent.futures import ThreadPoolExecutor, as_completed
import httpx
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn

console = Console()

class OriginExploiter:
    def __init__(self, timeout: int = 15, verbose: bool = False, depth: str = 'basic'):
        self.timeout = timeout
        self.verbose = verbose
        self.depth = depth
        
        # Exploitation signatures
        self.csrf_patterns = [
            r'csrf[_-]?token["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})["\']',
            r'_token["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})["\']',
            r'authenticity[_-]?token["\']?\s*[:=]\s*["\']([a-zA-Z0-9+/=]{16,})["\']',
            r'<input[^>]*name=["\']_token["\'][^>]*value=["\']([^"\']+)["\']',
            r'<meta[^>]*name=["\']csrf-token["\'][^>]*content=["\']([^"\']+)["\']'
        ]
        
        self.sensitive_headers = [
            'set-cookie', 'authorization', 'x-api-key', 'x-auth-token',
            'x-csrf-token', 'x-xsrf-token', 'x-session-token'
        ]
        
        self.admin_paths = [
            '/admin', '/administrator', '/admin.php', '/admin/', '/wp-admin',
            '/dashboard', '/panel', '/control', '/manage', '/backend',
            '/cpanel', '/plesk', '/webmin', '/phpmyadmin', '/adminer',
            '/admin/login', '/admin/dashboard', '/admin/panel',
            '/management', '/console', '/supervisor', '/operator'
        ]
        
        self.debug_paths = [
            '/debug', '/test', '/dev', '/development', '/.env',
            '/phpinfo.php', '/info.php', '/server-info', '/server-status',
            '/.git/config', '/config', '/configuration', '/settings',
            '/env', '/environment', '/debug/vars', '/debug/routes',
            '/swagger', '/api-docs', '/docs', '/documentation',
            '/actuator', '/health', '/metrics', '/status'
        ]
        
        self.api_paths = [
            '/api', '/api/v1', '/api/v2', '/rest', '/graphql',
            '/api/users', '/api/admin', '/api/config', '/api/keys',
            '/api/tokens', '/api/auth', '/api/login', '/api/session'
        ]
        
        # Framework fingerprints
        self.framework_signatures = {
            'laravel': [
                r'laravel_session',
                r'XSRF-TOKEN',
                r'Laravel Framework',
                r'Illuminate\\',
                r'APP_KEY'
            ],
            'django': [
                r'csrfmiddlewaretoken',
                r'Django',
                r'sessionid',
                r'CSRF_COOKIE'
            ],
            'wordpress': [
                r'wp-content',
                r'wp-includes',
                r'wp-admin',
                r'WordPress'
            ],
            'flask': [
                r'session',
                r'Flask',
                r'SECRET_KEY',
                r'Werkzeug'
            ],
            'express': [
                r'connect\.sid',
                r'Express',
                r'X-Powered-By.*Express'
            ]
        }
    
    def discover_origin_ips(self, target: str) -> List[str]:
        """Discover origin IPs using multiple techniques"""
        parsed = urlparse(target)
        domain = parsed.netloc
        
        origin_ips = set()
        
        # Method 1: DNS Resolution
        dns_ips = self._dns_resolution(domain)
        origin_ips.update(dns_ips)
        
        # Method 2: Subdomain enumeration and IP collection
        subdomain_ips = self._subdomain_ip_discovery(domain)
        origin_ips.update(subdomain_ips)
        
        # Method 3: Certificate transparency logs
        ct_ips = self._certificate_transparency_ips(domain)
        origin_ips.update(ct_ips)
        
        # Method 4: Historical DNS records
        historical_ips = self._historical_dns_lookup(domain)
        origin_ips.update(historical_ips)
        
        # Method 5: Shodan/Censys-like discovery (simulated)
        search_ips = self._search_engine_discovery(domain)
        origin_ips.update(search_ips)
        
        # Filter out CDN IPs and invalid IPs
        filtered_ips = self._filter_cdn_ips(list(origin_ips))
        
        return filtered_ips
    
    def exploit_origin(self, target: str, origin_ip: str) -> List[Dict]:
        """Exploit a discovered origin IP"""
        parsed = urlparse(target)
        domain = parsed.netloc
        
        exploits = []
        
        # Test basic connectivity
        if not self._test_origin_connectivity(origin_ip, domain):
            return exploits
        
        # Collect all paths to test
        test_paths = []
        test_paths.extend(self.admin_paths)
        test_paths.extend(self.debug_paths)
        test_paths.extend(self.api_paths)
        
        if self.depth == 'deep':
            test_paths.extend(self._generate_deep_paths(domain))
        
        # Test paths concurrently
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_path = {}
            
            for path in test_paths:
                future = executor.submit(self._test_origin_path, origin_ip, domain, path)
                future_to_path[future] = path
            
            for future in as_completed(future_to_path):
                path = future_to_path[future]
                try:
                    result = future.result()
                    if result:
                        exploits.extend(result)
                except Exception as e:
                    if self.verbose:
                        console.print(f"[red]Error testing {path}: {str(e)}[/red]")
        
        return exploits
    
    def _dns_resolution(self, domain: str) -> List[str]:
        """Basic DNS resolution"""
        try:
            ips = []
            result = socket.getaddrinfo(domain, None)
            for item in result:
                ip = item[4][0]
                if self._is_valid_ip(ip):
                    ips.append(ip)
            return list(set(ips))
        except:
            return []
    
    def _subdomain_ip_discovery(self, domain: str) -> List[str]:
        """Discover IPs from common subdomains"""
        subdomains = [
            f'www.{domain}', f'mail.{domain}', f'ftp.{domain}',
            f'admin.{domain}', f'api.{domain}', f'dev.{domain}',
            f'staging.{domain}', f'test.{domain}', f'origin.{domain}',
            f'direct.{domain}', f'server.{domain}'
        ]
        
        ips = []
        for subdomain in subdomains:
            try:
                result = socket.getaddrinfo(subdomain, None)
                for item in result:
                    ip = item[4][0]
                    if self._is_valid_ip(ip):
                        ips.append(ip)
            except:
                continue
        
        return list(set(ips))
    
    def _certificate_transparency_ips(self, domain: str) -> List[str]:
        """Simulate certificate transparency log discovery"""
        # In a real implementation, this would query CT logs
        # For now, we'll return empty list as this requires external APIs
        return []
    
    def _historical_dns_lookup(self, domain: str) -> List[str]:
        """Simulate historical DNS record lookup"""
        # In a real implementation, this would query services like SecurityTrails
        # For now, we'll return empty list as this requires external APIs
        return []
    
    def _search_engine_discovery(self, domain: str) -> List[str]:
        """Simulate search engine discovery of IPs"""
        # In a real implementation, this would use Shodan/Censys APIs
        # For now, we'll return empty list as this requires API keys
        return []
    
    def _filter_cdn_ips(self, ips: List[str]) -> List[str]:
        """Filter out known CDN IP ranges"""
        cdn_ranges = [
            # Cloudflare
            '173.245.48.0/20', '103.21.244.0/22', '103.22.200.0/22',
            '103.31.4.0/22', '141.101.64.0/18', '108.162.192.0/18',
            '190.93.240.0/20', '188.114.96.0/20', '197.234.240.0/22',
            '198.41.128.0/17', '162.158.0.0/15', '104.16.0.0/13',
            '104.24.0.0/14', '172.64.0.0/13', '131.0.72.0/22',
            
            # Fastly
            '23.235.32.0/20', '43.249.72.0/22', '103.244.50.0/24',
            '103.245.222.0/23', '103.245.224.0/24', '104.156.80.0/20',
            '146.75.0.0/16', '151.101.0.0/16', '157.52.64.0/18',
            '167.82.0.0/17', '167.82.128.0/20', '167.82.160.0/20',
            '167.82.224.0/20', '172.111.64.0/18', '185.31.16.0/22',
            '199.27.72.0/21', '199.232.0.0/16',
            
            # Amazon CloudFront
            '13.32.0.0/15', '13.35.0.0/16', '18.160.0.0/15',
            '52.222.128.0/17', '54.182.0.0/16', '54.192.0.0/16',
            '54.230.0.0/16', '54.239.128.0/18', '54.239.192.0/19',
            '54.240.128.0/18', '99.84.0.0/16', '205.251.192.0/19',
            '216.137.32.0/19'
        ]
        
        filtered_ips = []
        for ip in ips:
            is_cdn = False
            try:
                ip_obj = ipaddress.ip_address(ip)
                for cdn_range in cdn_ranges:
                    if ip_obj in ipaddress.ip_network(cdn_range):
                        is_cdn = True
                        break
                
                if not is_cdn:
                    filtered_ips.append(ip)
            except:
                continue
        
        return filtered_ips
    
    def _is_valid_ip(self, ip: str) -> bool:
        """Check if IP is valid and not private/reserved"""
        try:
            ip_obj = ipaddress.ip_address(ip)
            return not (ip_obj.is_private or ip_obj.is_reserved or ip_obj.is_loopback)
        except:
            return False
    
    def _test_origin_connectivity(self, origin_ip: str, domain: str) -> bool:
        """Test if origin IP is accessible"""
        try:
            client = httpx.Client(timeout=self.timeout)
            response = client.get(
                f"http://{origin_ip}/",
                headers={'Host': domain},
                follow_redirects=False
            )
            client.close()
            return response.status_code < 500
        except:
            return False
    
    def _test_origin_path(self, origin_ip: str, domain: str, path: str) -> List[Dict]:
        """Test a specific path on origin IP"""
        exploits = []
        
        try:
            # Test both HTTP and HTTPS
            for scheme in ['http', 'https']:
                url = f"{scheme}://{origin_ip}{path}"
                
                client = httpx.Client(
                    timeout=self.timeout,
                    verify=False,  # Ignore SSL errors for origin testing
                    follow_redirects=True
                )
                
                response = client.get(url, headers={'Host': domain})
                
                # Analyze response
                analysis = self._analyze_origin_response(response, origin_ip, path, scheme)
                exploits.extend(analysis)
                
                client.close()
                
        except Exception as e:
            if self.verbose:
                console.print(f"[red]Error testing {origin_ip}{path}: {str(e)}[/red]")
        
        return exploits
    
    def _analyze_origin_response(self, response: httpx.Response, origin_ip: str, 
                                path: str, scheme: str) -> List[Dict]:
        """Analyze origin response for vulnerabilities"""
        exploits = []
        content = response.text
        headers = dict(response.headers)
        
        # Check for CSRF tokens
        csrf_findings = self._find_csrf_tokens(content)
        for token in csrf_findings:
            exploits.append({
                'type': 'csrf_token',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': 'medium',
                'evidence': f'CSRF token found: {token[:20]}...',
                'full_token': token,
                'status_code': response.status_code
            })
        
        # Check for admin panels
        if self._is_admin_panel(content, headers, path):
            severity = 'critical' if response.status_code == 200 else 'high'
            exploits.append({
                'type': 'admin_panel',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': severity,
                'evidence': f'Admin panel accessible at {scheme}://{origin_ip}{path}',
                'status_code': response.status_code
            })
        
        # Check for sensitive headers
        sensitive_headers = self._find_sensitive_headers(headers)
        for header, value in sensitive_headers.items():
            exploits.append({
                'type': 'sensitive_header',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': 'medium',
                'evidence': f'Sensitive header: {header}',
                'header_name': header,
                'header_value': value[:50] + '...' if len(value) > 50 else value,
                'status_code': response.status_code
            })
        
        # Check for API documentation leaks
        if self._is_api_docs(content, headers, path):
            exploits.append({
                'type': 'api_leak',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': 'high',
                'evidence': f'API documentation exposed at {scheme}://{origin_ip}{path}',
                'status_code': response.status_code
            })
        
        # Check for debug information
        debug_info = self._find_debug_info(content)
        if debug_info:
            exploits.append({
                'type': 'debug_leak',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': 'high',
                'evidence': f'Debug information exposed: {debug_info}',
                'status_code': response.status_code
            })
        
        # Check for framework fingerprints
        framework = self._detect_framework(content, headers)
        if framework:
            exploits.append({
                'type': 'framework_detection',
                'origin_ip': origin_ip,
                'path': path,
                'scheme': scheme,
                'severity': 'low',
                'evidence': f'Framework detected: {framework}',
                'framework': framework,
                'status_code': response.status_code
            })
        
        return exploits
    
    def _find_csrf_tokens(self, content: str) -> List[str]:
        """Find CSRF tokens in content"""
        tokens = []
        for pattern in self.csrf_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            tokens.extend(matches)
        return list(set(tokens))
    
    def _is_admin_panel(self, content: str, headers: Dict, path: str) -> bool:
        """Check if response indicates an admin panel"""
        admin_indicators = [
            'admin', 'dashboard', 'control panel', 'management',
            'administrator', 'login', 'sign in', 'authentication'
        ]
        
        content_lower = content.lower()
        path_lower = path.lower()
        
        # Check path
        if any(indicator in path_lower for indicator in admin_indicators):
            return True
        
        # Check content
        if any(indicator in content_lower for indicator in admin_indicators):
            # Additional checks to reduce false positives
            if any(keyword in content_lower for keyword in ['password', 'username', 'login form']):
                return True
        
        return False
    
    def _find_sensitive_headers(self, headers: Dict) -> Dict[str, str]:
        """Find sensitive headers"""
        sensitive = {}
        for header, value in headers.items():
            if header.lower() in self.sensitive_headers:
                sensitive[header] = value
        return sensitive
    
    def _is_api_docs(self, content: str, headers: Dict, path: str) -> bool:
        """Check if response contains API documentation"""
        api_indicators = [
            'swagger', 'openapi', 'api documentation', 'rest api',
            'graphql', 'api explorer', 'postman', 'insomnia'
        ]
        
        content_lower = content.lower()
        path_lower = path.lower()
        
        return any(indicator in content_lower or indicator in path_lower 
                  for indicator in api_indicators)
    
    def _find_debug_info(self, content: str) -> Optional[str]:
        """Find debug information in content"""
        debug_patterns = [
            r'APP_KEY\s*=\s*([^\s\n]+)',
            r'SECRET_KEY\s*=\s*([^\s\n]+)',
            r'DATABASE_URL\s*=\s*([^\s\n]+)',
            r'API_KEY\s*=\s*([^\s\n]+)',
            r'DEBUG\s*=\s*True',
            r'FLASK_ENV\s*=\s*development',
            r'Exception\s+Traceback',
            r'Fatal error:',
            r'Warning:.*in\s+/.+\.php'
        ]
        
        for pattern in debug_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                return match.group(0)
        
        return None
    
    def _detect_framework(self, content: str, headers: Dict) -> Optional[str]:
        """Detect web framework"""
        content_lower = content.lower()
        headers_str = ' '.join([f"{k}: {v}" for k, v in headers.items()]).lower()
        
        for framework, signatures in self.framework_signatures.items():
            for signature in signatures:
                if re.search(signature.lower(), content_lower) or \
                   re.search(signature.lower(), headers_str):
                    return framework
        
        return None
    
    def _generate_deep_paths(self, domain: str) -> List[str]:
        """Generate additional paths for deep scanning"""
        deep_paths = [
            # Common backup files
            '/backup', '/backup.sql', '/backup.zip', '/db.sql',
            '/database.sql', '/dump.sql', '/site.zip', '/www.zip',
            
            # Configuration files
            '/config.php', '/config.json', '/settings.php', '/local_settings.py',
            '/production.py', '/development.py', '/.htaccess', '/web.config',
            
            # Log files
            '/logs', '/log', '/access.log', '/error.log', '/debug.log',
            '/application.log', '/laravel.log', '/django.log',
            
            # Version control
            '/.git', '/.svn', '/.hg', '/.bzr',
            '/.git/HEAD', '/.git/config', '/.git/logs/HEAD',
            
            # IDE files
            '/.vscode', '/.idea', '/nbproject',
            
            # Temporary files
            '/tmp', '/temp', '/cache', '/.tmp', '/.cache',
            
            # Framework specific
            '/vendor', '/node_modules', '/composer.json', '/package.json',
            '/requirements.txt', '/Gemfile', '/pom.xml',
            
            # Cloud metadata
            '/metadata', '/.aws', '/.azure', '/gcp',
            
            # Monitoring endpoints
            '/ping', '/health-check', '/status.php', '/server-status',
            '/nginx_status', '/fpm-status'
        ]
        
        return deep_paths
